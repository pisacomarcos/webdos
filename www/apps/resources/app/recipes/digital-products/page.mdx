import { AcademicCapSolid, BoltSolid, PuzzleSolid } from "@medusajs/icons"
import { LearningPath } from "docs-ui"

export const metadata = {
  title: `Digital Products Recipe`,
}

# {metadata.title}

This recipe provides the general steps to implement digital products in your Medusa application.

## Overview

Digital products are stored privately using a storage service like S3. When the customer buys this type of product, an email is sent to them where they can download the product.

Medusa doesn't have a built-in concept of a digital product since our focus is standardizing features and implementations, then offering the building blocks that enable you to build your use case.

You can create a Digital Product Module that introduces the concept of a digital product and links it to existing product concepts in the Product Module.

---

## Install a File Provider Module

A file provider module handles storage functionalities in Medusa. This includes uploading, retrieving, and downloading files, among other features.

Use a file provider module to manage your stored digital products.

During development, you can use the Local File Provider Module, which is installed by default in your store. For production, check out available file provider modules or create your own.

<CardList items={[
  {
    href: "/architectural-modules/file",
    title: "File Provider Modules",
    text: "Check out available file provider modules.",
    startIcon: <PuzzleSolid />,
    showLinkIcon: false
  },
  {
    href: "/references/file-provider-module",
    title: "Create a File Provider Module",
    text: "Learn how to create a file provider module.",
    startIcon: <AcademicCapSolid />,
    showLinkIcon: false
  },
]} />

---

## Install a Notification Provider Module

A notification provider module handles sending notifications to users and customers.

For digital products, a notification provider module allows you to send the customer an email or another form of notification with a link to download the file they purchased.

You can use one of Medusa’s notification provider modules or create your own.

{/* TODO add links */}

<CardList items={[
  {
    href: "/architectural-modules/notification",
    title: "Notification Provider Modules",
    text: "Check out available official notification provider modules.",
    startIcon: <PuzzleSolid />,
    showLinkIcon: false
  },
  {
    href: "#",
    title: "Create a Notification Provider Module",
    text: "Learn how to create a custom notification service.",
    startIcon: <AcademicCapSolid />,
    showLinkIcon: false,
    badge: {
      variant: "blue",
      children: "Guide Soon"
    }
  },
]} />

---

## Create Digital Product Module

Your custom features and functionalities are implemented inside modules. The module is integrated into the Medusa application without any implications on existing functionalities.

The module will hold your custom data models and the service implementing digital-product-related features.

<Card
  href="#"
  title="How to Create a Module"
  text="Learn how to create a module."
  startIcon={<AcademicCapSolid />}
  showLinkIcon={false}
/>

<Details summaryContent="Example: Create the Digital Product Module">

  In this section, you’ll create the skeleton of the Digital Product Module. In later sections, you’ll add more resources to it.
  
  Start by creating the directory `src/modules/digital-product`.
  
  Then, create the file `src/modules/digital-product/service.ts` with the following content:
  
  ```ts title="src/modules/digital-product/service.ts"
  class DigitalProductModuleService {
    // TODO
  }
  
  export default DigitalProductModuleService
  ```
  
  A module must export a service. So, you implement a dummy service for now.
  
  Next, create the file `src/modules/digital-product/index.ts` with the following content:
  
  ```ts title="src/modules/digital-product/index.ts"
  import DigitalProductModuleService from "./service"
  
  export default {
    service: DigitalProductModuleService,
  }
  ```
  
  This file holds the definition of the module.
  
  Finally, add the module to `medusa-config.js` into the `modules` object:
  
  ```js title="medusa-config.js"
  const modules = {
    digitalProductModuleService: {
      resolve: "./modules/digital-product"
    },
    // ...
  }
  ```

</Details>

---

## Create Custom Data Model

A data model represents a table in the database. You can define in your module data models to store data related to your custom features.

To represent a digital product, it's recommended to create a data model that has a `variant_id` field. In a later section, you’ll learn how to add a relationship to the Product Module’s `ProductVariant` data model.

<Card
  href="#"
  title="How to Create a Data Model"
  text="Learn how to create a data model."
  startIcon={<AcademicCapSolid />}
  showLinkIcon={false}
/>

<Details summaryContent="Example: Create ProductMedia Data Model">

  In this section, you’ll create a `ProductMedia` data model that represents your digital products.
    
  Before creating the data model, create the file `src/types/digital-product/product-media.ts` that holds common types:
  
  ```ts title="src/types/digital-product/product-media.ts"
  export enum MediaType {
    MAIN = "main",
    PREVIEW = "preview"
  }
  ```
  
  Then, create the file `src/modules/digital-product/models/product-media.ts` with the following content:
  
  ```ts title="src/modules/digital-product/models/product-media.ts"
  import { Entity, Enum, PrimaryKey, Property } from "@mikro-orm/core"
  import { createPsqlIndexStatementHelper, BaseEntity } from "@medusajs/utils"
  import { MediaType } from "../../../types/digital-product/product-media"
  
  const VariantIdIndex = createPsqlIndexStatementHelper({
    name: "IDX_product_media_variant_id",
    tableName: "product_media",
    columns: "variant_id",
  }).MikroORMIndex
  
  @Entity({ tableName: "product_media" })
  export class ProductMedia extends BaseEntity {
    @PrimaryKey({ columnType: "text" })
    id: string
  
    @Property({ columnType: "text" })
    name: string
  
    @Enum({ items: ["main", "preview"] })
    type: MediaType
  
    @Property({ columnType: "text" })
    file_key: string
    
    @Property({ columnType: "text" })
    mime_type: string
  
    @VariantIdIndex()
    @Property({ columnType: "text" })
    variant_id: string
  }
  ```
  
  The `ProductMedia` data model has fields relevant to digital products. Most importantly, it has a `variant_id` field that will later be used for its relationship with the Product Module.
  
  To reflect the data model in the database, you must create a migration.
  
  <Note>
  
  Learn how to generate a migration in [this guide](!docs!/basics/data-models#create-a-migration).
  
  </Note>
  
  Create the file `src/modules/digital-product/migrations/Migration20240509093233.ts` with the following content:
  
  ```ts title="src/modules/digital-product/migrations/Migration20240509093233.ts"
  import { Migration } from '@mikro-orm/migrations';
  
  export class Migration20240509093233 extends Migration {
  
    async up(): Promise<void> {
      this.addSql('create table if not exists "product_media" ("id" text not null, "name" text not null, "type" text check ("type" in (\'main\', \'preview\')) not null, "file_key" text not null, "mime_type" text not null, "variant_id" text not null, constraint "product_media_pkey" primary key ("id"));');
      this.addSql('CREATE INDEX IF NOT EXISTS "IDX_product_media_variant_id" ON "product_media" (variant_id);');
    }
  
    async down(): Promise<void> {
      this.addSql('drop table if exists "product_media" cascade;');
    }
  
  }
  ```
  
  To run the migrations, run the `build` command, then the `migrations run` command:
  
  ```bash npm2yarn
  npx medusa migrations run
  ```

</Details>

---

## Implement Data Management Features

Your module’s main service holds the management and other related features. Then, in other resources, such as an API route, you can resolve the service from the Medusa container and use its functionalities.

Medusa facilitates implementing data-management features by providing a service factory. This service factory implements basic data-management features, so you only need to implement features specific to your module.

<CardList items={[
  {
    href: "#",
    title: "How to use the Service Factory",
    text: "Learn about the service factory and how to use it in your service.",
    startIcon: <AcademicCapSolid />,
    showLinkIcon: false
  },
  {
    href: "#",
    title: "Implement Database Operations in a Service",
    text: "Learn how to perform database operations like create a record in a service.",
    startIcon: <AcademicCapSolid />,
    showLinkIcon: false
  },
]} />

<Details summaryContent="Example: Add Implementation of DigitalProductModuleService">
    
  In this section, you’ll modify the `DigitalProductModuleService` you created earlier to provide data-management functionalities of the `ProductMedia` data model.
  
  First, change the content of `src/types/digital-product/product-media.ts` to include more common types:
  
  ```ts title="src/types/digital-product/product-media.ts"
  import { ProductVariantDTO } from "@medusajs/types"
  
  export enum MediaType {
    MAIN = "main",
    PREVIEW = "preview"
  }
  
  export type ProductMediaDTO = {
    id: string
    name: string
    type: MediaType
    file_key: string
    mime_type: string
    variant_id: string
    variant?: ProductVariantDTO
  }
  
  export type CreateProductMediaDTO = {
    name: string
    file_key: string
    variant_id: string
    type: string
    mime_type: string
  }
  
  export type UpdateProductMediaDTO = {
    name?: string
    file_key?: string
    variant_id?: string
    type?: string
    mime_type?: string
  }

  ```
  
  Then, change the content of `src/modules/digital-product/service.ts` to the following:
  
  ```ts title="src/modules/digital-product/service.ts"
  import { ProductMedia } from "./models/product-media"
  import { ModulesSdkUtils } from "@medusajs/utils"
  import { ModulesSdkTypes } from "@medusajs/types"
  import { 
    CreateProductMediaDTO, 
    ProductMediaDTO,
    UpdateProductMediaDTO
  } from "../../types/digital-product/product-media"
  
  type InjectedDependencies = {
    productMediaService: ModulesSdkTypes.InternalModuleService<
      any
    >
  }
  
  class DigitalProductModuleService extends ModulesSdkUtils
    .abstractModuleServiceFactory<
      InjectedDependencies,
      ProductMediaDTO,
      {
        ProductMedia: {
          dto: ProductMediaDTO
        }
      }
    >(ProductMedia, [], {}) {
      protected readonly productMediaService_: 
        ModulesSdkTypes.InternalModuleService<ProductMedia>
  
      constructor(
        {
          productMediaService
        }: InjectedDependencies,
      ) {
        // @ts-ignore
        super(...arguments)
  
        this.productMediaService_ = productMediaService
      }
  
      async create(
        data: CreateProductMediaDTO,
      ): Promise<ProductMediaDTO> {
        const productMedia = await this.productMediaService_
          .create(
            data, 
          )
  
        return productMedia
      }
  
      async update(
        id: string,
        data: UpdateProductMediaDTO,
      ): Promise<ProductMediaDTO> {
        const productMedia = await this.productMediaService_
          .update({
            ...data,
            id
          })
  
        return productMedia
      }
    }
  
  export default DigitalProductModuleService
  ```
  
  The `DigitalProductModuleService` now extends the generated service returned by the service factory. The generated service already has basic features implemented, such as listing, retrieving, and deleting records.
  
  You implement in your service the `create` and `update` methods, which aren’t generated automatically. In them, use the `productMediaService` generated for the `ProductMedia` data model in your module's container. It has methods to perform database operations on the data model.

</Details>

---

## Add Relationship to Product Variants

As mentioned in a previous section, the product media has a `variant_id` that points to the saleable product variant.

The Product Module implements product variants. However, modules are isolated. So, to reference data models and records from other modules, you can use module relationships.

The Medusa application resolves module relationships without creating an actual dependency between the modules. This allows you to associate more fields with existing modules while maintaining module isolation.

<Card
  href="#"
  title="Module Relationships"
  text="Learn about what module relationships are and how to use them."
  startIcon={<AcademicCapSolid />}
  showLinkIcon={false}
/>

<Details summaryContent="Example: Create Relationship to Product Module">
    
  In this section, you’ll create a relationship from the Digital Product Module to the Product Module.
  
  To do that, add the following `__joinerConfig` method to the `DigitalProductModuleService`:
  
  ```ts title="src/modules/digital-product/service.ts"
  // other imports...
  import { ModuleJoinerConfig } from "@medusajs/types"
  import { Modules } from "@medusajs/modules-sdk"
  
  // ...
  
  class DigitalProductModuleService extends ModulesSdkUtils
    .abstractModuleServiceFactory<
      // ...
    >(
      // ...
    ) {
      // ...
      
      __joinerConfig(): ModuleJoinerConfig {
        return {
          serviceName: "digitalProductModuleService",
          primaryKeys: ["id"],
          alias: [
            {
              name: "product_media",
              args: {
                entity: ProductMedia.name
              }
            }
          ],
          relationships: [
            {
              serviceName: Modules.PRODUCT,
              alias: "variant",
              primaryKey: "id",
              foreignKey: "variant_id",
              args: {
                methodSuffix: "Variants"
              }
            }
          ]
        }
      }
    }
  ```
  
  This informs the Medusa application that, whenever there’s a `variant_id` field in your module’s data models, look for the record it’s referencing in the `variant` alias (which is the `ProductVariant` data model) of the Product Module.
  
  <Note>

  Learn more about the data returned in the `__joinerConfig` method here.
  
  </Note>
  
  Next, change the module’s entry in the `modules` object in `medusa-config.js` to the following:
  
  ```ts title="medusa-config.js"
  const modules = {
    digitalProductModuleService: {
      resolve: "./modules/digital-product",
      definition: {
        isQueryable: true,
        key: "digitalProductModuleService",
        registrationName: "digitalProductModuleService"
      }
    },
    // ...
  }
  ```

</Details>

---

## Add Custom API Routes

API routes expose your features to external applications, such as the admin dashboard or the storefront.

You can create custom API routes that allow merchants to list and create digital products. In these API routes, you resolve the Digital Product Module’s main service to use its data-management features.

To utilize the relationship to the Product Module, you use the remote query to fetch data across modules.

<CardList itemsPerRow={2} items={[
  {
    href: "#",
    title: "API Routes",
    text: "Learn how to create an API route.",
    startIcon: <AcademicCapSolid />,
    showLinkIcon: false
  },
  {
    href: "#",
    title: "Remote Query",
    text: "Learn about what the remote query is and how to use it.",
    startIcon: <AcademicCapSolid />,
    showLinkIcon: false
  },
]} />

<Details summaryContent="Example: Custom API Routes for Digital Products">

  In this section, you’ll create a List and Create API routes to retrieve and create digital products.
  
  ### Create API Route
  
  In the Create API route, you want to create not only the product media but also the associated product variant if no ID is specified.
  
  You’ll implement this logic in a workflow, then use the workflow in the API route.
  
  Start by changing the content of `src/types/digital-product/product-media.ts` to include more types:
  
  ```ts title="src/types/digital-product/product-media.ts"
  import { 
    ProductVariantDTO,
    CreateProductWorkflowInputDTO
  } from "@medusajs/types"
  
  export enum MediaType {
    MAIN = "main",
    PREVIEW = "preview"
  }
  
  export type ProductMediaDTO = {
    id: string
    name: string
    type: MediaType
    file_key: string
    mime_type: string
    variant_id: string
    variant?: ProductVariantDTO
  }
  
  export type CreateProductMediaDTO = {
    name: string
    file_key: string
    type: MediaType
    mime_type: string
    variant_id?: string
  }
  
  export type UpdateProductMediaDTO = {
    name?: string
    file_key?: string
    variant_id?: string
    type?: MediaType
    mime_type?: string
  }
  
  export type FilterableProductMediaProps = {
    name?: string[]
    file_key?: string[]
    variant_id?: string[]
    type?: MediaType[]
    mime_type?: string[]
  }
  
  export type CreateProductMediaWorkflowInput = 
      CreateProductMediaDTO & {
        product?: CreateProductWorkflowInputDTO
      }

  ```
  
  Then, create the file `src/workflows/digital-product/create.ts` with the following content:
  
  ```ts title="src/workflows/digital-product/create.ts"
  import { 
    createWorkflow,
    WorkflowData,
    createStep,
    StepResponse
  } from "@medusajs/workflows-sdk"
  import { createProductsWorkflow } from "@medusajs/core-flows"
  import { 
    CreateProductMediaDTO, 
    CreateProductMediaWorkflowInput,
    ProductMediaDTO
  } from "../../types/digital-product/product-media"
  import DigitalProductModuleService from 
    "../../modules/digital-product/service"
  import { RemoteQueryFunction } from "@medusajs/modules-sdk"
  import { 
    ContainerRegistrationKeys,
    remoteQueryObjectFromString
  } from "@medusajs/utils"
  
  const tryToCreateProductVariantStep = createStep(
    "try-to-create-product-variant-step",
    async (input: CreateProductMediaWorkflowInput, { container }) => {
      if (input.product && !input.variant_id) {
        const { result, errors } = await createProductsWorkflow(container)
          .run({
            input: {
              products: [input.product]
            },
            throwOnError: false
          })
  
        if (errors.length) {
          throw errors[0].error
        }
  
        input.variant_id = result[0].variants[0].id
  
        delete input.product
      }
  
      return new StepResponse(input)
    }
  )
  
  const createProductMediaStep = createStep(
    "create-product-media-step",
    async (input: CreateProductMediaDTO, { container }) => {
      const digitalProductModuleService: 
        DigitalProductModuleService = container.resolve(
          "digitalProductModuleService"
        )
  
      const productMedia = await digitalProductModuleService.create(
        input
      )
  
      return new StepResponse(productMedia)
    }
  )
  
  const retrieveProductMediaWithVariant = createStep(
    "retrieve-product-media-with-variant-step",
    async (input: ProductMediaDTO, { container }) => {
      const remoteQuery: RemoteQueryFunction = container.resolve(
        ContainerRegistrationKeys.REMOTE_QUERY
      )
  
      const query = remoteQueryObjectFromString({
        entryPoint: "product_media",
        fields: [
          "id",
          "name",
          "type",
          "file_key",
          "mime_type",
          "variant.*"
        ],
        variables: {
          filters: {
            id: input.id
          }
        }
      })
  
      const result = await remoteQuery(query)
  
      return new StepResponse(result[0])
    }
  )
  
  type WorkflowInput = {
    data: CreateProductMediaWorkflowInput
  }
  
  export const createProductMediaWorkflow = createWorkflow(
    "create-product-media-workflow",
    function (input: WorkflowData<WorkflowInput>) {
      // create the product variant before creating the media
      // if variant_id isn't passed
      const normalizedInput = tryToCreateProductVariantStep(input.data)
      
      const productMedia = createProductMediaStep(normalizedInput)
  
      return retrieveProductMediaWithVariant(productMedia)
    }
  )
  ```
  
  This workflow has three steps:
  
  1. If a `variant_id` field isn’t passed and a `product` field is passed, create the product using Medusa’s `createProductsWorkflow` and set the ID of the variant in the `variant_id` field.
  2. Use the `DigitalProductModuleService` to create the product media.
  3. Use the remote query to retrieve the product media along with the variant it references.
  
  Finally, create the `src/api/admin/digital-products/route.ts` file with the following content:
  
  ```ts title="src/api/admin/digital-products/route.ts"
  import {
    MedusaRequest,
    MedusaResponse
  } from "@medusajs/medusa"
  import { MedusaError } from "@medusajs/utils"
  import { 
    CreateProductMediaWorkflowInput
  } from "../../../types/digital-product/product-media"
  import { 
    createProductMediaWorkflow
  } from "../../../workflows/digital-product/create"
  
  type CreateProductMediaReq = CreateProductMediaWorkflowInput
  
  export async function POST(
    req: MedusaRequest<CreateProductMediaReq>,
    res: MedusaResponse
  ) {
    // validation omitted for simplicity
    const { 
      result, 
      errors
    } = await createProductMediaWorkflow(req.scope)
      .run({
        input: {
          data: {
            ...req.body
          }
        },
        throwOnError: false
      })
  
    if (errors.length) {
      throw new MedusaError(
        MedusaError.Types.DB_ERROR, 
        errors[0].error
      )
    }
  
    res.json({
      product_media: result
    })
  }
  ```
  
  This adds a `POST` API route at `/admin/digital-products` that executes the `createProductMediaWorkflow` workflow.
  
  To test it out, start the Medusa application:
  
  ```bash npm2yarn
  npm run dev
  ```
  
  Next, authenticate as an admin user as explained in the [API Reference]
  
  Then, upload a file using the Upload API route:
  
  ```bash
  curl -X POST 'http://localhost:9000/admin/uploads' \
  -H 'Authorization: Bearer {bearer_token}' \
  --form 'files=@"/path/to/file"'
  ```
  
  Make sure to replace `/path/to/file` with the path to the file to upload. Copy the `id` field’s value as you’ll use it as the `file_key`'s value when creating the digital product.
  
  Finally, send a request to the API route you created:
  
  ```bash
  curl -X POST 'localhost:9000/admin/digital-products' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer {bearer_token}' \
  --data '{
      "name": "Harry Potter",
      "file_key": "file.png",
      "type": "main",
      "mime_type": "image/png",
      "product": {
          "title": "Harry Potter Books",
          "variants": [
              {
                  "title": "Harry Potter 1"
              }
          ]
      }
  }'
  ```
  
  This creates a product and a variant, and a product media that references the created variant.
  
  You’ll receive a response similar to the following:
  
  ```json
  {
      "product_media": {
          "id": "promed_01HXEFRMS79293ASYVN8YY9Y0J",
          "name": "Harry Potter",
          "type": "main",
          "file_key": "file.png",
          "mime_type": "image/png",
          "variant_id": "variant_01HXEFRMR3B09EZJX23P1DMYFQ",
          "variant": {
              "id": "variant_01HXEFRMR3B09EZJX23P1DMYFQ",
              "title": "Harry Potter 1",
              // ...
          }
      }
  }
  ```
  
  ### List API Route
  
  Next, you’ll create the List API route that returns a list of digital products.
  
  To do that, add the following to `src/api/admin/digital-products/route.ts`:
  
  ```ts title="src/api/admin/digital-products/route.ts"
  // other imports...
  import { RemoteQueryFunction } from "@medusajs/modules-sdk"
  import { 
    ContainerRegistrationKeys,
    remoteQueryObjectFromString
  } from "@medusajs/utils"
  
  // ...
  
  export async function GET(
    req: MedusaRequest,
    res: MedusaResponse
  ) {
    const remoteQuery: RemoteQueryFunction = req.scope.resolve(
      ContainerRegistrationKeys.REMOTE_QUERY
    )
  
    const query = remoteQueryObjectFromString({
      entryPoint: "product_media",
      fields: [
        "id",
        "name",
        "type",
        "file_key",
        "mime_type",
        "variant.*"
      ],
    })
  
    const result = await remoteQuery(query)
  
    res.json({
      digital_products: result
    })
  }
  ```
  
  This creates a new `GET` API route at `/admin/digital-products` that retrieves the list of digital products and their associated variants.
  
  To test it out, send a request to the API route while your Medusa application is running:
  
  ```bash apiTesting testApiUrl="http://localhost:9000/admin/digital-products" testApiMethod="GET"
  curl 'localhost:9000/admin/digital-products' \
  -H 'Authorization: Bearer {bearer_token}' \
  ```
  
  You’ll receive a list of digital products.

</Details>
    

---

## Customize Admin Dashboard

You can extend the Medusa Admin to provide merchants with an interface to manage digital products. You can inject widgets into existing pages or create new pages. 

In your customizations, you send requests to the API routes you created to create and list digital products.

<CardList items={[
  {
    href: "#",
    title: "Create a Widget",
    text: "Learn how to create a widget in the Medusa Admin.",
    startIcon: <AcademicCapSolid />,
    showLinkIcon: false
  },
  {
    href: "#",
    title: "Create UI Route",
    text: "Learn how to create a UI route in the Medusa Admin.",
    startIcon: <AcademicCapSolid />,
    showLinkIcon: false
  },
]} />

<Details summaryContent="Example: Digital Products Page in Admin">

  In this example, you’ll add a single page that lists the digital products and allows you to create a new one. The implementation will be minimal for the purpose of simplicity, so you can elaborate on it based on your use case.
      
  Before starting off, make sure to install the necessary dependencies in your Medusa application project:

  ```bash npm2yarn
  npm install medusa-react @tanstack/react-query@4.22 @medusajs/ui
  ```

  This installs the necessary packages to use the Medusa React client and the [Medusa UI package](https://docs.medusajs.com/ui).

  You also need to create types for the expected requests and responses of the API Routes you created. This is helpful when using Medusa React’s custom hooks. To do that, create the file `src/types/product-media.ts` with the following content:

  ```ts title="src/types/product-media.ts" badgeLabel="Medusa Application"
  import { 
    MediaType, 
    ProductMedia, 
  } from "../models/product-media"

  export type ListProductMediasRequest = {
    // no expected parameters
  };

  export type ListProductMediasResponse = {
    product_medias: ProductMedia[]
    count: number
  };

  export type CreateProductMediaRequest = {
    variant_id: string
    name: string
    file_key: string
    type?: MediaType
    mime_type: string
  };

  export type CreateProductMediaResponse = {
    product_media: ProductMedia
  };
  ```

  You can now create your admin UI route. To do that, create the file `src/admin/routes/product-media/page.tsx` with the following content:

  ```tsx title="src/admin/routes/product-media/page.tsx" badgeLabel="Medusa Application"
  import { RouteConfig } from "@medusajs/admin"
  import { DocumentText } from "@medusajs/icons"
  import { useAdminCustomQuery } from "medusa-react"
  import { 
    ListProductMediasRequest, 
    ListProductMediasResponse,
  } from "../../../types/product-media"
  import { 
    Button, 
    Container, 
    Drawer, 
    Heading, 
    Table,
  } from "@medusajs/ui"
  import { Link } from "react-router-dom"
  import { RouteProps } from "@medusajs/admin-ui"
  import ProductMediaCreateForm 
    from "../../components/product-media/CreateForm"

  const ProductMediaListPage = (props: RouteProps) => {
    const { data, isLoading } = useAdminCustomQuery<
      ListProductMediasRequest, 
      ListProductMediasResponse
    >(
      "/product-media",
      ["product-media"]
    )

    return (
      <Container>
        <div className="flex justify-between mb-4">
          <Heading level="h1">Digital Products</Heading>
          <Drawer>
            <Drawer.Trigger>
              <Button>Create</Button>
            </Drawer.Trigger>
            <Drawer.Content>
              <Drawer.Header>
                <Drawer.Title>
                  Create Digital Product
                </Drawer.Title>
              </Drawer.Header>
              <Drawer.Body>
                <ProductMediaCreateForm {...props} />
              </Drawer.Body>
            </Drawer.Content>
          </Drawer>
        </div>
        {isLoading && <div>Loading...</div>}
        {data && !data.product_medias.length && (
          <div>No Digital Products</div>
        )}
        {data && data.product_medias.length > 0 && (
          <Table>
            <Table.Header>
              <Table.Row>
                <Table.HeaderCell>Product</Table.HeaderCell>
                <Table.HeaderCell>
                  Product Variant
                </Table.HeaderCell>
                <Table.HeaderCell>File Key</Table.HeaderCell>
                <Table.HeaderCell>Action</Table.HeaderCell>
              </Table.Row>
            </Table.Header>
            <Table.Body>
              {data.product_medias.map((product_media) => (
                <Table.Row key={product_media.id}>
                  <Table.Cell>
                    {product_media.variant.product.title}
                  </Table.Cell>
                  <Table.Cell>
                    {product_media.variant.title}
                  </Table.Cell>
                  <Table.Cell>
                    {product_media.file_key}
                  </Table.Cell>
                  <Table.Cell>
                    <Link to={`/a/products/${
                      product_media.variant.product_id
                    }`}>
                      View Product
                    </Link>
                  </Table.Cell>
                </Table.Row>
              ))}
            </Table.Body>
          </Table>
        )}
      </Container>
    )
  }

  export const config: RouteConfig = {
    link: {
      label: "Digital Products",
      icon: DocumentText,
    },
  }

  export default ProductMediaListPage
  ```

  This UI route will show under the sidebar with the label “Digital Products”. In the page, you use the `useAdminCustomQuery` hook imported from `medusa-react` to send a request to your custom “list digital products” API Route.

  In the page, you’ll show the list of digital products in a table, if there are any. You’ll also show a button that opens a drawer to the side of the page.

  In the drawer, you show the Create Digital Product form. To create this form, create the file `src/admin/components/product-media/CreateForm/index.tsx` with the following content:

  ```tsx title="src/admin/components/product-media/CreateForm/index.tsx" badgeLabel="Medusa Application"
  import { useState } from "react"
  import { MediaType } from "../../../../models/product-media"
  import { 
    useAdminCreateProduct, 
    useAdminCustomPost, 
    useAdminUploadProtectedFile,
  } from "medusa-react"
  import { 
    CreateProductMediaRequest, 
    CreateProductMediaResponse, 
  } from "../../../../types/product-media"
  import { 
    Button, 
    Container, 
    Input, 
    Label, 
    Select,
  } from "@medusajs/ui"
  import { RouteProps } from "@medusajs/admin-ui"
  import { useNavigate } from "react-router-dom"

  const ProductMediaCreateForm = ({
    notify,
  }: RouteProps) => {
    const [productName, setProductName] = useState("")
    const [
      productVariantName, 
      setProductVariantName,
    ] = useState("")
    const [name, setName] = useState("")
    const [type, setType] = useState("main")
    const [file, setFile] = useState<File>()

    const createProduct = useAdminCreateProduct()
    const uploadFile = useAdminUploadProtectedFile()
    const { 
      mutate: createDigitalProduct,
      isLoading,
    } = useAdminCustomPost<
      CreateProductMediaRequest,
      CreateProductMediaResponse
    >(
      "/product-media",
      ["product-media"]
    )

    const navigate = useNavigate()

    const handleSubmit = (
      e: React.FormEvent<HTMLFormElement>
    ) => {
      e.preventDefault()
      
      createProduct.mutate({
        title: productName,
        is_giftcard: false,
        discountable: false,
        options: [
          {
            title: "Digital Product",
          },
        ],
        variants: [
          {
            title: productVariantName,
            options: [
              {
                value: name, // can also be the file name
              },
            ],
            // for simplicity, prices are omitted from form.
            // Those can be edited from the product's page.
            prices: [],
          },
        ],
      }, {
        onSuccess: ({ product }) => {
          // upload file
          uploadFile.mutate(file, {
            onSuccess: ({ uploads }) => {
              if (!("key" in uploads[0])) {
                return
              }
              // create the digital product
              createDigitalProduct({
                variant_id: product.variants[0].id,
                name,
                file_key: uploads[0].key as string,
                type: type as MediaType,
                mime_type: file.type,
              }, {
                onSuccess: () => {
                  notify.success(
                    "Success", 
                    "Digital Product Created Successfully"
                  )
                  navigate("/a/product-media")
                },
              })
            },
          })
        },
      })
    }

    return (
      <Container>
        <form 
          onSubmit={handleSubmit} 
          className="flex flex-col gap-4"
        >
          <div className="flex gap-4 items-center">
            <Label>Product Name</Label>
            <Input 
              type="text" 
              placeholder="Product Name" 
              value={productName} 
              onChange={(e) => setProductName(e.target.value)}
            />
          </div>
          <div className="flex gap-4 items-center">
            <Label>Product Variant Name</Label>
            <Input 
              type="text" 
              placeholder="Product Variant" 
              value={productVariantName} 
              onChange={(e) => 
                setProductVariantName(e.target.value)
              }
            />
          </div>
          <div className="flex gap-4 items-center">
            <Label>Media Name</Label>
            <Input 
              type="text" 
              placeholder="Media Name" 
              value={name} 
              onChange={(e) => setName(e.target.value)}
            />
          </div>
          <div className="flex gap-4 items-center">
            <Label>Type</Label>
            <Select onValueChange={setType} value={type}>
              <Select.Trigger>
                <Select.Value placeholder="Type" />
              </Select.Trigger>
              <Select.Content className="z-50">
                <Select.Item value={"main"}>
                  Main
                </Select.Item>
                <Select.Item value={"preview"}>
                  Preview
                </Select.Item>
              </Select.Content>
            </Select>
          </div>
          <div className="flex gap-4 items-center">
            <Label>File</Label>
            <Input 
              type="file" 
              onChange={(e) => setFile(e.target.files[0])}
            />
          </div>
          <Button 
            variant="primary" 
            type="submit" 
            isLoading={
              createProduct.isLoading || 
              uploadFile.isLoading || 
              isLoading
            }>
            Create
          </Button>
        </form>
      </Container>
    )
  }

  export default ProductMediaCreateForm
  ```

  In this component, you create a form that accepts basic information needed to create the digital product. This form only accepts one file for one variant for simplicity purposes. You can expand on this based on your use case.

  Notice that an alternative approach would be to inject a widget to the Product Details page and allow users to upload the files from there. It depends on whether you’re only supporting Digital Products or you want the distinction between them, as done here.

  When the user submits the form, you first create a product with a variant. Then, you upload the file using the [Upload Protected File API Route](https://docs.medusajs.com/api/admin#uploads_postuploadsprotected). Finally, you create the digital product using the custom API Route you created.

  The product’s details can still be edited from the same Products interface, similar to regular products. You can edit its price, add more variants, and more.

  To test it out, run the `dev` command:

  ```bash npm2yarn
  npm run dev
  ```

  If you open the admin now, you’ll find a new Digital Products item in the sidebar. You can try adding Digital Products and viewing them.

</Details>

---

## Deliver Digital Products to the Customer

When a customer purchases a digital product, they should receive a link to download it.

You can create a subscriber that listens to the `order.placed` event. In the subscriber, you check for the digital products in the order and obtain the download URLs using the file provider module’s `getPresignedDownloadUrl` method.

<Note>

Following this approach assumes the file provider module you're using handles creating secure pre-signed URLs with an expiration mechanism. Alternatively, create a token on purchase using the API Key Module and create an API route that validates that token.

</Note>

In the subscriber, you can send a notification, such as an email, to the customer using the notification provider module of your choice. That notification would hold the download links to the products the customer purchased.

<Card
  href="!docs!/basics/events-and-subscribers"
  title="Create a Subscriber"
  text="Learn how to create a subscriber."
  startIcon={<AcademicCapSolid />}
  showLinkIcon={false}
/>

<Details summaryContent="Example">

  <Note>

  An alternative solution is to create a store download API Route that allows authenticated customers to download products they've purchased, then add the link to the API Route or a storefront page that calls the API Route in the email. Learn how to implement the download API Route [here](#download-product-after-purchase).

  </Note>

  Here’s an example of a subscriber that retrieves the download links and sends them to the customer using the installed notification provider module:
      
  ```ts title="src/subscribers/handle-order.ts" badgeLabel="Medusa Application"
  import { 
    type SubscriberConfig, 
    type SubscriberArgs,
  } from "@medusajs/medusa"
  import { 
    IOrderModuleService,
    IFileModuleService,
    INotificationModuleService
  } from "@medusajs/types"
  import { 
    ModuleRegistrationName,
  } from "@medusajs/modules-sdk"
  import DigitalProductModuleService 
    from "../modules/digital-product/service"

  export default async function handleOrderPlaced({ 
    data, container, 
  }: SubscriberArgs<{ id: string }>) {
    const orderModuleService: IOrderModuleService = 
      container.resolve(
        ModuleRegistrationName.ORDER
      )
    const fileModuleService: IFileModuleService = 
      container.resolve(
        ModuleRegistrationName.FILE
      )
    const notificationModuleService: INotificationModuleService = 
      container.resolve(ModuleRegistrationName.NOTIFICATION)
    const digitalProductModuleService:
      DigitalProductModuleService = container.resolve(
        "digitalProductModuleService"
      )

    const orderId = "data" in data ? data.data.id : data.id

    const order = await orderModuleService.retrieve(orderId, {
      relations: ["items"]
    })

    // find product medias in the order
    const urls = []
    for (const item of order.items) {
      const productMedias = await digitalProductModuleService
        .list({
          variant_id: [item.variant_id]
        })
        
      const downloadUrls = await Promise.all(
        productMedias.map(async (productMedia) => {
        
          // get the download URL from the file service
          return (await fileModuleService.retrieve(
            productMedia.file_key
          )).url
        })
      )

      urls.push(...downloadUrls)
    }

    notificationModuleService.create({
      to: order.email,
      template: "digital-download",
      channel: "email",
      data: {
        // any data necessary for your template...
        digital_download_urls: urls,
      },
    })
  }

  export const config: SubscriberConfig = {
    event: "order.placed",
  }
  ```
    
  The `handleOrderPlaced` subscriber function retrieves the order, loops over its items to find digital products and retrieve their download links, then uses the installed notification provider module to send the email, passing the URLs as a data payload. You can customize the sent data based on your template and your use case.

</Details>

---

## Customize or Build Storefront

Customers use your storefront to browse your digital products and purchase them. You can also provide other helpful features, such as previewing the digital product before purchase.

Medusa provides a Next.js storefront with standard commerce features including listing products, placing orders, and managing accounts. You can customize the storefront and cater its functionalities to support digital products.

Alternatively, you can build the storefront with your preferred tech stack. This guide has tips on building storefronts.

The rest of this section provides some guidelines on how to customize the Next.js storefront to support digital products.

<Note>

While our team ensures to maintain this section with the changes in the Next.js storefront, some changes may cause the code in this section to be outdated. If you encounter outdated code snippets, please submit [an issue](https://github.com/medusajs/medusa/issues/new?assignees=&labels=type:+docs&projects=&template=docs.yml).

</Note>

### Preview Digital Product

On the product detail page, you can add a button that allows customers to download a preview of the digital product.

To implement this, create a storefront API Route that allows you to fetch the digital product, then customize the Next.js storefront to show the preview button if a product is digital.

<Details summaryContent="Example">

  Start by creating a store API Route in your Medusa application that lists digital products.
    
  Create the file `src/api/store/digital-products/route.ts` with the following content:

  ```ts title="src/api/store/product-media/route.ts" badgeLabel="Medusa Application"
  import type { 
    MedusaRequest, 
    MedusaResponse,
  } from "@medusajs/medusa"
  import { 
    MediaType
  } from "../../../types/digital-product/product-media"
  import { RemoteQueryFunction } from "@medusajs/modules-sdk"
  import {
    ContainerRegistrationKeys,
    remoteQueryObjectFromString
  } from "@medusajs/utils"
  
  export const GET = async (
    req: MedusaRequest, 
    res: MedusaResponse
  ) => {
    const remoteQuery: RemoteQueryFunction = req.scope.resolve(
      ContainerRegistrationKeys.REMOTE_QUERY
    )
    const query = remoteQueryObjectFromString({
      entryPoint: "product_media",
      fields: [
        "id",
        "name",
        "file_key",
        "mime_type",
        "variant.*"
      ],
      variables: {
        filters: {
          type: MediaType.PREVIEW
        },
        // omitting pagination for simplicity
        skip: 0
      }
    })
  
    const { 
      rows, 
      metadata: { count }
    } = await remoteQuery(query)
  
    res.json({
      product_medias: rows,
      count,
    })
  }
  ```

  This adds a `GET` API route at `/store/product-media` that retrieves product media of type `preview` with their variant.

  {/* TODO check rest of steps */}

  Now, you can customize the Next.js Starter to show the preview button.

  First, if you're using TypeScript for your development, create the file `src/types/product-media.ts` with the following content:

  ```ts title="src/types/product-media.ts" badgeLabel="Storefront" badgeColor="blue"

  import { Product } from "@medusajs/medusa"
  import { ProductVariant } from "@medusajs/product"

  export enum ProductMediaVariantType {
    PREVIEW = "preview",
    MAIN = "main",
  }

  export type ProductMedia = {
    id: string
    variant_id: string
    name?: string
    file_key?: string
    mime_type?: string
    created_at?: Date
    updated_at?: Date
    type?: ProductMediaVariantType
    variants?: ProductVariant[]
  }

  export type DigitalProduct = Omit<Product, "variants"> & {
    product_medias?: ProductMedia[]
    variants?: DigitalProductVariant[]
  }

  export type DigitalProductVariant = ProductVariant & {
    product_medias?: ProductMedia
  }
  ```

  Then, add in `src/lib/data/index.ts` a new function that retrieves the product media of the product variant being viewed:

  ```ts title="src/lib/data/index.ts" badgeLabel="Storefront" badgeColor="blue"
  import { 
    ProductMedia,
  } from "types/product-media"
  import { Variant } from "../../types/medusa"

  // ... rest of the functions

  export async function getProductMediaPreviewByVariant(
    variant: Variant
  ): Promise<ProductMedia> {
    const { 
      product_medias,
    } = await medusaRequest(
      "GET", 
      `/product-media`,
      {
        query: {
          variant_ids: variant.id,
        },
      }
    )
    .then((res) => res.body)
    .catch((err) => {
      throw err
    })

    return product_medias[0]
  }
  ```

  To allow customers to download the file preview without exposing its URL, create a Next.js API route in the file `src/app/api/download/preview/route.ts` with the following content:

  ```ts title="src/app/api/download/preview/route.ts" badgeLabel="Storefront" badgeColor="blue"
  import { NextRequest, NextResponse } from "next/server"

  export async function GET(req: NextRequest) {
    // Get the file info from the URL
    const { 
      file_path, 
      file_name, 
      mime_type,
    } = Object.fromEntries(req.nextUrl.searchParams)

    // Fetch the file
    const fileResponse = await fetch(file_path)

    // Handle the case where the file could not be fetched
    if (!fileResponse.ok) {
      return new NextResponse("File not found", { status: 404 })
    }

    // Get the file content as a buffer
    const fileBuffer = await fileResponse.arrayBuffer()

    // Define response headers
    const headers = {
      "Content-Type": mime_type,
      // This sets the file name for the download
      "Content-Disposition": `attachment; filename="${
        file_name
      }"`,
    }

    // Create a NextResponse with the file content and headers
    const response = new NextResponse(fileBuffer, {
      status: 200,
      headers,
    })

    return response
  }
  ```

  Next, create the preview button in the file `src/modules/products/components/product-media-preview/index.tsx`:

  ```tsx title="src/modules/products/components/product-media-preview/index.tsx" badgeLabel="Storefront" badgeColor="blue"
  import Button from "@modules/common/components/button"
  import { ProductMedia } from "types/product-media"

  type Props = {
    media: ProductMedia
  }

  const ProductMediaPreview: React.FC<Props> = ({ media }) => {
    const downloadPreview = () => {
      window.location.href = `${
        process.env.NEXT_PUBLIC_BASE_URL
      }/api/download/preview?file_path=${
        media.file_key
        }&file_name=${
          media.name
          }&mime_type=${
            media.mime_type
          }`
    }

    return (
      <div>
        <Button variant="secondary" onClick={downloadPreview}>
          Download free preview
        </Button>
      </div>
    )
  }

  export default ProductMediaPreview
  ```

  Finally, add the button as one of the product actions defined in `src/modules/products/components/product-actions/index.tsx`. These are the actions shown to the customer in the product details page:

  ```tsx title="src/modules/products/components/product-actions/index.tsx" badgeLabel="Storefront" badgeColor="blue"
  // other imports...
  import { useState, useEffect } from "react"
  import ProductMediaPreview from "../product-media-preview"
  import { getProductMediaPreviewByVariant } from "@lib/data"
  import { ProductMedia } from "types/product-media"


  const ProductActions: React.FC<ProductActionsProps> = ({
    product,
  }) => {
    // other code...

    const [productMedia, setProductMedia] = useState<
      ProductMedia
    >()

    useEffect(() => {
      const getProductMedia = async () => {
        if (!variant) {return}
        await getProductMediaPreviewByVariant(variant)
        .then((res) => {
          setProductMedia(res)
        })
      }
      getProductMedia()
    }, [variant])

    return (
      <div>
        {/* other code... */}

        {productMedia && (
          <ProductMediaPreview media={productMedia} />
        )}

        <Button onClick={addToCart}>
          {!inStock ? "Out of stock" : "Add to cart"}
        </Button>
      </div>
    )
  }

  export default ProductActions
  ```

</Details>

### Update Product Tabs

In the product details page, additional information related to the product and its shipping details are shown at the bottom right side.

You can change this section to show information relevant to the product. For example, how many pages are in an e-book or how the e-book will be delivered to the customer.

<Details summaryContent="Example">

  {/* TODO check steps */}

  In this example, you'll change the content of the Product Information and Shipping & Returns tabs to show information relevant to the digital product. The Product Information tab will include custom information relevant to digital products, and the Shipping & Returns tab will be changed to "E-book delivery" and will hold details about how the e-book will be delivered to the customer.

  One way to store custom information relevant to the digital product is using the `metadata` field. For example, to store the number of pages of an e-book, set the `metadata` field to the following:

  ```json
  {
    "metadata": {
      "Pages": "420"
    }
  }
  ```

  Then, you can customize the product additional details section to loop through the `metadata` field's properties and show their information.

  Next, change the `ProductTabs`, `ProductInfoTab`, and `ShippingInfoTab` components defined in `src/modules/products/components/product-tabs/index.tsx` to the following:

  ```tsx title="src/modules/products/components/product-tabs/index.tsx" badgeLabel="Storefront" badgeColor="blue"
  const ProductTabs = ({ product }: ProductTabsProps) => {
    const tabs = useMemo(() => {
      return [
        {
          label: "Product Information",
          component: <ProductInfoTab product={product} />,
        },
        {
          label: "E-book delivery",
          component: <ShippingInfoTab />,
        },
      ]
    }, [product])
    // ... rest of code
  }

  const ProductInfoTab = ({ product }: ProductTabsProps) => {
    // map the metadata object to an array 
    const metadata = useMemo(() => {
      if (!product.metadata) {return []}
      return Object.keys(product.metadata).map((key) => {
        return [key, product.metadata?.[key]]
      })
    }, [product])

    return (
      <Tab.Panel className="text-small-regular py-8">
        <div className="grid grid-cols-2 gap-x-8">
          <div className="flex flex-col gap-y-4">
          {/* Map the metadata as product information */}
            {metadata &&
              metadata.slice(0, 2).map(([key, value], i) => (
                <div key={i}>
                  <span className="font-semibold">{key}</span>
                  <p>{value}</p>
                </div>
              ))}
          </div>
          <div className="flex flex-col gap-y-4">
            {metadata.length > 2 &&
              metadata.slice(2, 4).map(([key, value], i) => {
                return (
                  <div key={i}>
                    <span className="font-semibold">{key}</span>
                    <p>{value}</p>
                  </div>
                )
              })}
          </div>
        </div>
        {product.tags?.length ? (
          <div>
            <span className="font-semibold">Tags</span>
          </div>
        ) : null}
      </Tab.Panel>
    )
  }

  const ShippingInfoTab = () => {
    return (
      <Tab.Panel className="text-small-regular py-8">
        <div className="grid grid-cols-1 gap-y-8">
          <div className="flex items-start gap-x-2">
            <FastDelivery />
            <div>
              <span className="font-semibold">
                Instant delivery
              </span>
              <p className="max-w-sm">
                Your e-book will be delivered instantly via
                email. You can also download it from your 
                account anytime.
              </p>
            </div>
          </div>
          <div className="flex items-start gap-x-2">
            <Refresh />
            <div>
              <span className="font-semibold">
                Free previews
              </span>
              <p className="max-w-sm">
                Get a free preview of the e-book before 
                you buy it. Just click the
                button above to download it.
              </p>
            </div>
          </div>
        </div>
      </Tab.Panel>
    )
  }
  ```

  This changes the titles of the tabs and their content.

</Details>

### Change Shipping Form in Checkout

When a customer purchases a digital product, the shipping form shown during checkout is irrelevant. So, you can change its content to instead only ask for the customer's name and email.

<Details summaryContent="Example">

  {/* TODO check steps */}

  The checkout flow is managed by a checkout context defined in `src/lib/context/checkout-context.tsx`. Change the content of the file to the following:

  ```tsx title="src/lib/context/checkout-context.tsx" badgeLabel="Storefront" badgeColor="blue"
  "use client"

  import { medusaClient } from "@lib/config"
  import useToggleState, { StateType } from "@lib/hooks/use-toggle-state"
  import {
    Address,
    Cart,
    Customer,
    StorePostCartsCartReq,
  } from "@medusajs/medusa"
  import Wrapper from "@modules/checkout/components/payment-wrapper"
  import { isEqual } from "lodash"
  import {
    formatAmount,
    useCart,
    useCartShippingOptions,
    useMeCustomer,
    useRegions,
    useSetPaymentSession,
    useUpdateCart,
  } from "medusa-react"
  import { useRouter } from "next/navigation"
  import React, { createContext, useContext, useEffect, useMemo } from "react"
  import { FormProvider, useForm, useFormContext } from "react-hook-form"
  import { useStore } from "./store-context"
  import Spinner from "@modules/common/icons/spinner"

  type AddressValues = {
    first_name: string
    last_name: string
    country_code: string
  }

  export type CheckoutFormValues = {
    shipping_address: AddressValues
    billing_address: AddressValues
    email: string
  }

  interface CheckoutContext {
    cart?: Omit<Cart, "refundable_amount" | "refunded_total">
    shippingMethods: { label?: string; value?: string; price: string }[]
    isLoading: boolean
    addressReady: boolean
    shippingReady: boolean
    paymentReady: boolean
    readyToComplete: boolean
    sameAsBilling: StateType
    editAddresses: StateType
    editShipping: StateType
    editPayment: StateType
    isCompleting: StateType
    initPayment: () => Promise<void>
    setAddresses: (addresses: CheckoutFormValues) => void
    setSavedAddress: (address: Address) => void
    setShippingOption: (soId: string) => void
    setPaymentSession: (providerId: string) => void
    onPaymentCompleted: () => void
  }

  const CheckoutContext = createContext<CheckoutContext | null>(null)

  interface CheckoutProviderProps {
    children?: React.ReactNode
  }

  const IDEMPOTENCY_KEY = "create_payment_session_key"

  export const CheckoutProvider = ({ children }: CheckoutProviderProps) => {
    const {
      cart,
      setCart,
      addShippingMethod: {
        mutate: setShippingMethod,
        isLoading: addingShippingMethod,
      },
      completeCheckout: { mutate: complete },
    } = useCart()

    const { customer } = useMeCustomer()
    const { countryCode } = useStore()

    const methods = useForm<CheckoutFormValues>({
      defaultValues: mapFormValues(customer, cart, countryCode),
      reValidateMode: "onChange",
    })

    const {
      mutate: setPaymentSessionMutation,
      isLoading: settingPaymentSession,
    } = useSetPaymentSession(cart?.id!)

    const { mutate: updateCart, isLoading: updatingCart } = useUpdateCart(
      cart?.id!
    )

    const { shipping_options } = useCartShippingOptions(cart?.id!, {
      enabled: !!cart?.id,
    })

    const { regions } = useRegions()

    const { resetCart, setRegion } = useStore()
    const { push } = useRouter()

    const editAddresses = useToggleState()
    const sameAsBilling = useToggleState(
      cart?.billing_address && cart?.shipping_address
        ? isEqual(cart.billing_address, cart.shipping_address)
        : true
    )

    const editShipping = useToggleState()
    const editPayment = useToggleState()

    /**
    * Boolean that indicates if a part of the checkout is loading.
    */
    const isLoading = useMemo(() => {
      return addingShippingMethod || settingPaymentSession || updatingCart
    }, [addingShippingMethod, settingPaymentSession, updatingCart])

    /**
    * Boolean that indicates if the checkout is ready to be completed. A checkout is ready to be completed if
    * the user has supplied a email, shipping address, billing address, shipping method, and a method of payment.
    */
    const { addressReady, shippingReady, paymentReady, readyToComplete } =
      useMemo(() => {
        const addressReady =
          !!cart?.shipping_address && !!cart?.billing_address && !!cart?.email

        const shippingReady =
          addressReady &&
          !!(
            cart?.shipping_methods &&
            cart.shipping_methods.length > 0 &&
            cart.shipping_methods[0].shipping_option
          )

        const paymentReady = shippingReady && !!cart?.payment_session

        const readyToComplete = addressReady && shippingReady && paymentReady

        return {
          addressReady,
          shippingReady,
          paymentReady,
          readyToComplete,
        }
      }, [cart])

    useEffect(() => {
      if (addressReady && !shippingReady) {
        editShipping.open()
      }
    }, [addressReady, shippingReady, editShipping])

    const shippingMethods = useMemo(() => {
      if (shipping_options && cart?.region) {
        return shipping_options?.map((option) => ({
          value: option.id,
          label: option.name,
          price: formatAmount({
            amount: option.amount || 0,
            region: cart.region,
          }),
        }))
      }

      return []
    }, [shipping_options, cart])

    /**
    * Resets the form when the cart changed.
    */
    useEffect(() => {
      if (cart?.id) {
        methods.reset(mapFormValues(customer, cart, countryCode))
      }
    }, [customer, cart, methods, countryCode])

    useEffect(() => {
      if (!cart) {
        editAddresses.open()
        return
      }

      if (cart?.shipping_address && cart?.billing_address) {
        editAddresses.close()
        return
      }

      editAddresses.open()
    }, [cart])

    /**
    * Method to set the selected shipping method for the cart. This is called when the user selects a shipping method, such as UPS, FedEx, etc.
    */
    const setShippingOption = async (soId: string) => {
      if (cart) {
        setShippingMethod(
          { option_id: soId },
          {
            onSuccess: ({ cart }) => setCart(cart),
          }
        )
      }
    }

    /**
    * Method to create the payment sessions available for the cart. Uses a idempotency key to prevent duplicate requests.
    */
    const initPayment = async () => {
      if (cart?.id && !cart.payment_sessions?.length && cart?.items?.length) {
        return medusaClient.carts
          .createPaymentSessions(cart.id, {
            "Idempotency-Key": IDEMPOTENCY_KEY,
          })
          .then(({ cart }) => cart && setCart(cart))
          .catch((err) => err)
      }
    }

    useEffect(() => {
      // initialize payment session
      const start = async () => {
        await initPayment()
      }
      start()
    }, [cart?.region, cart?.id, cart?.items])

    /**
    * Method to set the selected payment session for the cart. This is called when the user selects a payment provider, such as Stripe, PayPal, etc.
    */
    const setPaymentSession = (providerId: string) => {
      if (cart) {
        setPaymentSessionMutation(
          {
            provider_id: providerId,
          },
          {
            onSuccess: ({ cart }) => {
              setCart(cart)
            },
          }
        )
      }
    }

    const setSavedAddress = (address: Address) => {
      const setValue = methods.setValue

      setValue("shipping_address", {
        country_code: address.country_code || "",
        first_name: address.first_name || "",
        last_name: address.last_name || "",
      })
    }

    /**
    * Method that validates if the cart's region matches the shipping address's region. If not, it will update the cart region.
    */
    const validateRegion = (countryCode: string) => {
      if (regions && cart) {
        const region = regions.find((r) =>
          r.countries.map((c) => c.iso_2).includes(countryCode)
        )

        if (region && region.id !== cart.region.id) {
          setRegion(region.id, countryCode)
        }
      }
    }

    /**
    * Method that sets the addresses and email on the cart.
    */
    const setAddresses = (data: CheckoutFormValues) => {
      const { shipping_address, billing_address, email } = data

      validateRegion(shipping_address.country_code)

      const payload: StorePostCartsCartReq = {
        shipping_address,
        email,
      }

      if (isEqual(shipping_address, billing_address)) {
        sameAsBilling.open()
      }

      if (sameAsBilling.state) {
        payload.billing_address = shipping_address
      } else {
        payload.billing_address = billing_address
      }

      updateCart(payload, {
        onSuccess: ({ cart }) => setCart(cart),
      })
    }

    const isCompleting = useToggleState()

    /**
    * Method to complete the checkout process. This is called when the user clicks the "Complete Checkout" button.
    */
    const onPaymentCompleted = () => {
      isCompleting.open()
      complete(undefined, {
        onSuccess: ({ data }) => {
          push(`/order/confirmed/${data.id}`)
          resetCart()
        },
      })
      isCompleting.close()
    }

    return (
      <FormProvider {...methods}>
        <CheckoutContext.Provider
          value={{
            cart,
            shippingMethods,
            isLoading,
            addressReady,
            shippingReady,
            paymentReady,
            readyToComplete,
            sameAsBilling,
            editAddresses,
            editShipping,
            editPayment,
            isCompleting,
            initPayment,
            setAddresses,
            setSavedAddress,
            setShippingOption,
            setPaymentSession,
            onPaymentCompleted,
          }}
        >
          {isLoading && cart?.id === "" ? (
            <div className="flex justify-center items-center h-screen">
              <div className="w-auto">
                <Spinner size={40} />
              </div>
            </div>
          ) : (
            <Wrapper paymentSession={cart?.payment_session}>{children}</Wrapper>
          )}
        </CheckoutContext.Provider>
      </FormProvider>
    )
  }

  export const useCheckout = () => {
    const context = useContext(CheckoutContext)
    const form = useFormContext<CheckoutFormValues>()
    if (context === null) {
      throw new Error(
        "useProductActionContext must be used within a ProductActionProvider"
      )
    }
    return { ...context, ...form }
  }

  /**
  * Method to map the fields of a potential customer and 
  * the cart to the checkout form values. Information is 
  * assigned with the following priority:
  * 1. Cart information
  * 2. Customer information
  * 3. Default values - null
  */
  const mapFormValues = (
    customer?: Omit<Customer, "password_hash">,
    cart?: Omit<Cart, "refundable_amount" | "refunded_total">,
    currentCountry?: string
  ): CheckoutFormValues => {
    const customerShippingAddress = 
      customer?.shipping_addresses?.[0]
    const customerBillingAddress = 
      customer?.billing_address

    return {
      shipping_address: {
        first_name:
          cart?.shipping_address?.first_name ||
          customerShippingAddress?.first_name ||
          "",
        last_name:
          cart?.shipping_address?.last_name ||
          customerShippingAddress?.last_name ||
          "",
        country_code:
          currentCountry ||
          cart?.shipping_address?.country_code ||
          customerShippingAddress?.country_code ||
          "",
      },
      billing_address: {
        first_name:
          cart?.billing_address?.first_name ||
          customerBillingAddress?.first_name ||
          "",
        last_name:
          cart?.billing_address?.last_name ||
          customerBillingAddress?.last_name ||
          "",
        country_code:
          cart?.shipping_address?.country_code ||
          customerBillingAddress?.country_code ||
          "",
      },
      email: cart?.email || customer?.email || "",
    }
  }
  ```

  This removes all references to shipping fields that you don't need for digital products.

  Next, change the content of `src/modules/checkout/components/shipping-address/index.tsx` to remove the unnecessary address fields:

  ```tsx title="src/modules/checkout/components/shipping-address/index.tsx" badgeLabel="Storefront" badgeColor="blue"
  import { CheckoutFormValues } from "@lib/context/checkout-context"
  import { emailRegex } from "@lib/util/regex"
  import ConnectForm from "@modules/common/components/connect-form"
  import Input from "@modules/common/components/input"
  import { useMeCustomer } from "medusa-react"
  import AddressSelect from "../address-select"
  import CountrySelect from "../country-select"
  import Checkbox from "@modules/common/components/checkbox"
  import { Container } from "@medusajs/ui"

  const ShippingAddress = ({
    checked,
    onChange,
  }: {
    checked: boolean
    onChange: () => void
  }) => {
    const { customer } = useMeCustomer()

    return (
      <div>
        {customer && (customer.shipping_addresses?.length || 0) > 0 && (
          <Container className="mb-6 flex flex-col gap-y-4 p-5">
            <p className="text-small-regular">
              {`Hi ${customer.first_name}, do you want to use one of your saved addresses?`}
            </p>
            <AddressSelect addresses={customer.shipping_addresses} />
          </Container>
        )}
        <ConnectForm<CheckoutFormValues>>
          {({ register, formState: { errors, touchedFields } }) => (
            <>
              <div className="grid grid-cols-2 gap-4">
                <Input
                  label="First name"
                  {...register("shipping_address.first_name", {
                    required: "First name is required",
                  })}
                  autoComplete="given-name"
                  errors={errors}
                  touched={touchedFields}
                  required
                />
                <Input
                  label="Last name"
                  {...register("shipping_address.last_name", {
                    required: "Last name is required",
                  })}
                  autoComplete="family-name"
                  errors={errors}
                  touched={touchedFields}
                  required
                />
                <CountrySelect
                  {...register("shipping_address.country_code", {
                    required: "Country is required",
                  })}
                  autoComplete="country"
                  errors={errors}
                  touched={touchedFields}
                  required
                />
              </div>
              <div className="my-8">
                <Checkbox
                  label="Same as billing address"
                  checked={checked}
                  onChange={onChange}
                />
              </div>
              <div className="grid grid-cols-2 gap-4 mb-4">
                <Input
                  label="Email"
                  {...register("email", {
                    required: "Email is required",
                    pattern: emailRegex,
                  })}
                  autoComplete="email"
                  errors={errors}
                  touched={touchedFields}
                  required
                />
              </div>
            </>
          )}
        </ConnectForm>
      </div>
    )
  }

  export default ShippingAddress
  ```

  And update the content of `src/modules/checkout/components/addresses/index.tsx` to only show the necessary address fields:

  ```tsx title="src/modules/checkout/components/addresses/index.tsx" badgeLabel="Storefront" badgeColor="blue"
  import { useCheckout } from "@lib/context/checkout-context"
  import { Button } from "@medusajs/ui"
  import Spinner from "@modules/common/icons/spinner"
  import ShippingAddress from "../shipping-address"

  const Addresses = () => {
    const {
      sameAsBilling: { state: checked, toggle: onChange },
      editAddresses: { state: isOpen, open },
      editShipping: { close: closeShipping },
      editPayment: { close: closePayment },
      setAddresses,
      handleSubmit,
      cart,
    } = useCheckout()

    const handleEdit = () => {
      open()
      closeShipping()
      closePayment()
    }

    return (
      <div className="bg-white">
        <div className={"text-xl-semi flex items-center gap-x-4 px-8 pb-6 pt-8"}>
          <div className="bg-gray-900 w-8 h-8 rounded-full text-white flex justify-center items-center text-sm">
            1
          </div>
          <h2>Shipping address</h2>
        </div>
        {isOpen ? (
          <div className="px-8 pb-8">
            <ShippingAddress checked={checked} onChange={onChange} />
            <Button
              className="max-w-[200px] mt-6"
              onClick={handleSubmit(setAddresses)}
            >
              Continue to delivery
            </Button>
          </div>
        ) : (
          <div>
            <div className="bg-gray-50 px-8 py-6 text-small-regular">
              {cart && cart.shipping_address ? (
                <div className="flex items-start gap-x-8">
                  <div className="bg-green-400 rounded-full min-w-[24px] h-6 flex items-center justify-center text-white text-small-regular">
                    ✓
                  </div>
                  <div className="flex items-start justify-between w-full">
                    <div className="flex flex-col">
                      <span>
                        {cart.shipping_address.first_name}{" "}
                        {cart.shipping_address.last_name}
                        {cart.shipping_address.country}
                      </span>
                      <div className="mt-4 flex flex-col">
                        <span>{cart.email}</span>
                      </div>
                    </div>
                    <div>
                      <button onClick={handleEdit}>Edit</button>
                    </div>
                  </div>
                </div>
              ) : (
                <div className="">
                  <Spinner />
                </div>
              )}
            </div>
          </div>
        )}
      </div>
    )
  }

  export default Addresses
  ```

  Finally, change the shipping details shown in the order confirmation page by replacing the content of `src/modules/order/components/shipping-details/index.tsx` with the following:

  ```tsx title="src/modules/order/components/shipping-details/index.tsx" badgeLabel="Storefront" badgeColor="blue"
  import { Order } from "@medusajs/medusa"
  import { Heading, Text } from "@medusajs/ui"
  import Divider from "@modules/common/components/divider"
  import { formatAmount } from "medusa-react"

  type ShippingDetailsProps = {
    order: Order
  }

  const ShippingDetails = ({ order }: ShippingDetailsProps) => {
    return (
      <div>
        <Heading level="h2" className="flex flex-row text-3xl-regular my-6">
          Delivery
        </Heading>
        <div className="flex items-start gap-x-8">
          <div className="flex flex-col w-1/3">
            <Text className="txt-medium-plus text-ui-fg-base mb-1">
              Shipping Address
            </Text>
            <Text className="txt-medium text-ui-fg-subtle">
              {order.shipping_address.first_name}{" "}
              {order.shipping_address.last_name}
            </Text>
            <Text className="txt-medium text-ui-fg-subtle">
              {order.shipping_address.country_code?.toUpperCase()}
            </Text>
          </div>

          <div className="flex flex-col w-1/3 ">
            <Text className="txt-medium-plus text-ui-fg-base mb-1">Contact</Text>
            <Text className="txt-medium text-ui-fg-subtle">{order.email}</Text>
          </div>

          <div className="flex flex-col w-1/3">
            <Text className="txt-medium-plus text-ui-fg-base mb-1">Method</Text>
            <Text className="txt-medium text-ui-fg-subtle">
              {order.shipping_methods[0].shipping_option.name} (
              {formatAmount({
                amount: order.shipping_methods[0].price,
                region: order.region,
              })
                .replace(/,/g, "")
                .replace(/\./g, ",")}
              )
            </Text>
          </div>
        </div>
        <Divider className="mt-8" />
      </div>
    )
  }

  export default ShippingDetails
  ```

</Details>

### Download Product After Purchase

After the customer purchases the digital product you can show a download button to allow them to immediately download the product.

<Details summaryContent="Example">

  Before you implement the storefront changes, you need to create a new API Route in the Medusa application that validates that the customer has already purchased the digital product before returning the presigned URL to download it.
    
  You’ll implement this logic in a workflow. Create the file `src/workflows/digital-product/get-url.ts` with the following content:

  ```ts title="src/api/store/product-media/download/route.ts" badgeLabel="Medusa Application"
  import { 
    createWorkflow,
    transform,
    createStep,
    StepResponse
  } from "@medusajs/workflows-sdk"
  import { 
    IOrderModuleService,
    IFileModuleService
  } from "@medusajs/types"
  import { ModuleRegistrationName } from "@medusajs/modules-sdk"
  import DigitalProductModuleService from "../../modules/digital-product/service"
  import { MediaType } from "../../types/digital-product/product-media"
  
  type GetPurchasedProductMediaUrlWorkflowInput = {
    variant_id: string
    customer_id: string
  }
  
  type CheckVariantStepInput = 
    GetPurchasedProductMediaUrlWorkflowInput
  
  const checkVariantPurchasedStep = createStep(
    "check-variant-purchased-step",
    async ({ 
      variant_id,
      customer_id
    }: CheckVariantStepInput, { 
      container
    }) => {
      const orderModuleService: IOrderModuleService = 
        container.resolve(ModuleRegistrationName.ORDER)
      const orders = await orderModuleService.list({
        customer_id,
      }, {
        relations: ["items"],
      })
      
      const found = orders.some((order) => (
        order.items.some((item) => {
          if (item.variant_id === variant_id) {
            return true
          }
  
          return false
        })
      ))
  
      if (!found) {
        throw new Error("Customer hasn't purchased this product.")
      }
    }
  )
  
  type GetProductMediaStepInput = {
    variant_id: string
  }
  
  const getProductMediaStep = createStep(
    "get-product-media-step",
    async ({ variant_id }: GetProductMediaStepInput, { container }) => {
      // get the product media and the presigned URL
      const digitalProductModuleService: 
        DigitalProductModuleService = container.resolve(
          "digitalProductModuleService"
        )
      const productMedias = await digitalProductModuleService
        .list({
          type: MediaType.MAIN,
          variant_id,
        })
  
      return new StepResponse({ product_media: productMedias[0] })
    }
  )
  
  type GetFileUrlStepInput = {
    id: string
  }
  
  const getFileUrlStep = createStep(
    "get-file-url-step",
    async ({ id }: GetFileUrlStepInput, { container }) => {
      const fileModuleService: IFileModuleService = container
        .resolve(ModuleRegistrationName.FILE)
  
      const file = await fileModuleService.retrieve(
        id
      )
  
      return new StepResponse(file.url)
    }
  )
  
  type GetPurchasedProductMediaUrlWorkflowOutput = {
    url: string
    name: string
    mime_type: string
  }
  
  export const getPurchasedProductMediaUrlWorkflow = 
    createWorkflow<
      GetPurchasedProductMediaUrlWorkflowInput,
      GetPurchasedProductMediaUrlWorkflowOutput
    >(
      "get-purchased-product-media-url-workflow",
      function (input) {
        checkVariantPurchasedStep(input)
  
        const { product_media } = getProductMediaStep({
          variant_id: input.variant_id
        })
  
        const url = getFileUrlStep({
          id: product_media.file_key
        })
  
        const result = transform(
          {
            url,
            product_media
          },
          (transformInput) => ({
            url: transformInput.url,
            name: transformInput.product_media.name,
            mime_type: transformInput.product_media.mime_type
          })
        )
  
        return result
      }
    )
  ```

  This workflow has three steps:
    
  1. Check that the customer has purchased this product variant before.
  2. Retrieve the product media associated with the variant.
  3. Retrieve the pre-signed URL of the product media file.
  4. Return the details of the file.
  
  Then, create the file `src/api/store/digital-products/download/[variant_id]/route.ts` in the Medusa backend with the following content:

  ```ts title="src/api/store/digital-products/download/[variant_id]/route.ts"
  import type { 
    MedusaRequest, 
    MedusaResponse, 
  } from "@medusajs/medusa"
  import { getPurchasedProductMediaUrlWorkflow } from "../../../../../workflows/digital-product/get-url"
  
  export const GET = async (
    req: MedusaRequest, 
    res: MedusaResponse
  ) => {
    const { result } = await getPurchasedProductMediaUrlWorkflow(
      req.scope
    ).run({
      input: {
        variant_id: req.params.variant_id,
        customer_id: req.user.customer_id
      }
    })
  
    res.json(result)
  }
  ```
  
  Then, add the `authenticate` middleware to this API Route in `src/api/middlewares.ts`:
  
  ```tsx
  import {
    type MiddlewaresConfig, 
    authenticate
  } from "@medusajs/medusa"
  
  export const config: MiddlewaresConfig = {
    routes: [
      {
        matcher: "/store/product-media/download/*",
        middlewares: [
          authenticate("store", ["session", "bearer"])
        ],
      },
    ],
  }
  ```

  This ensures that only logged-in customers can access this API Route.

  {/* TODO check steps */}

  You can use this API Route in your storefront to add a button that allows downloading the purchased digital product.

  To mask the presigned URL, create a Next.js API route at `src/app/api/download/main/[variant_id]/route.ts` with the following content:

  ```ts title="src/app/api/download/main/[variant_id]/route.ts" badgeLabel="Storefront" badgeColor="blue"
  import { NextRequest, NextResponse } from "next/server"

  export async function GET(
    req: NextRequest,
    { params }: { params: Record<string, any> }
  ) {
    // Get the variant ID from the URL
    const { variant_id } = params

    // Define the API URL
    const apiUrl = `${
      process.env.NEXT_PUBLIC_MEDUSA_BACKEND_URL
    }/store/product-media/download/${variant_id}`

    // Fetch the file data
    const { 
      url,
      name,
      mime_type,
    } = await fetch(apiUrl)
      .then((res) => res.json())

    // Handle the case where the file doesn't exist
    // or the customer didn't purchase the product
    if (!url) {
      return new NextResponse(
        "File doesn't exist", 
        { status: 401 }
      )
    }

    // Fetch the file
    const fileResponse = await fetch(url)

    // Handle the case where the file could not be fetched
    if (!fileResponse.ok) {
      return new NextResponse(
        "File not found",
        { status: 404 }
      )
    }

    // Get the file content as a buffer
    const fileBuffer = await fileResponse.arrayBuffer()

    // Define response headers
    const headers = {
      "Content-Type": mime_type,
      // This sets the file name for the download
      "Content-Disposition": `attachment; filename="${name}"`,
    }

    // Create a NextResponse with the PDF content and headers
    const response = new NextResponse(fileBuffer, {
      status: 200,
      headers,
    })

    return response
  }
  ```

  Finally, add a button in the storefront that uses this route to allow customers to download the digital product after purchase.

  For example, you can change the `src/modules/order/components/item/index.tsx` file that handles showing each of the order's items in the order confirmation page to include a new download button if the customer is logged-in:

  ```tsx title="src/modules/order/components/item/index.tsx" badgeLabel="Storefront" badgeColor="blue"
  import { LineItem, Region } from "@medusajs/medusa"
  import { Button, Table, Text, clx } from "@medusajs/ui"
  import LineItemOptions from "@modules/common/components/line-item-options"
  import LineItemPrice from "@modules/common/components/line-item-price"
  import LineItemUnitPrice from "@modules/common/components/line-item-unit-price"
  import Thumbnail from "@modules/products/components/thumbnail"
  import { useAccount } from "../../../../lib/context/account-context"

  type ItemProps = {
    item: Omit<LineItem, "beforeInsert">
    region: Region
  }

  const Item = ({ item, region }: ItemProps) => {
    const { customer } = useAccount()
    const handleDownload = async () => {
      window.location.href = `${process.env.NEXT_PUBLIC_BASE_URL}/api/download/main/${item.variant_id}`
    }
    return (
      <Table.Row className="w-full">
        <Table.Cell className="!pl-0 p-4 w-24">
          <div className="flex w-16">
            <Thumbnail thumbnail={item.thumbnail} size="square" />
          </div>
        </Table.Cell>

        <Table.Cell className="text-left">
          <Text className="txt-medium-plus text-ui-fg-base">{item.title}</Text>
          <LineItemOptions variant={item.variant} />
        </Table.Cell>

        <Table.Cell className="!pr-0">
          <span className="!pr-0 flex flex-col items-end h-full justify-center">
            <span className="flex gap-x-1 ">
              <Text className="text-ui-fg-muted">{item.quantity}x </Text>
              <LineItemUnitPrice item={item} region={region} style="tight" />
            </span>

            <LineItemPrice item={item} region={region} style="tight" />
            {customer && (
              <Button
                variant="secondary" 
                onClick={() => handleDownload()}>
                Download
              </Button>
            )}
          </span>
        </Table.Cell>
      </Table.Row>
    )
  }

  export default Item
  ```

</Details>
